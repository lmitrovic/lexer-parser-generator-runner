# -*- coding: utf-8 -*-
"""MyProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_nwxJ6JmAuEGPFXJqxBW0mvLiA7mjhvr
"""

from enum import Enum, auto

class Class(Enum):
    PLUS = auto()
    MINUS = auto()
    STAR = auto()
    FWDSLASH = auto()

    OR = auto()
    XOR = auto()
    AND = auto()
    NOT = auto()

    EQ = auto()
    NEQ = auto()
    LT = auto()
    GT = auto()
    LTE = auto()
    GTE = auto()

    LPAREN = auto()
    RPAREN = auto()
    LBRACKET = auto()
    RBRACKET = auto()
    LBRACE = auto()
    RBRACE = auto()

    ASSIGN = auto()
    SEMICOLON = auto()
    COMMA = auto()
    FULLSTOP = auto()

    TYPE = auto()
    INTEGER = auto()
    CHAR = auto()
    STRING = auto()
    REAL = auto()
    BOOLEAN = auto()

    IF = auto()
    ELSE = auto()
    WHILE = auto()
    FOR = auto()
    REPEAT = auto()
    UNTIL = auto()

    BREAK = auto()
    CONTINUE = auto()
    BEGIN = auto()
    END = auto()
    VAR = auto()
    COLON = auto()
    PROCEDURE = auto()
    FUNCTION = auto()
    ARRAY = auto()
    OF = auto()
    TWOFULLSTOP = auto()
    TO = auto()
    DOWNTO = auto()
    DO = auto()
    DIV = auto()
    MOD = auto()
    THEN = auto()
    EXIT = auto()

    ADDRESS = auto()

    ID = auto()
    EOF = auto()

"""Klasa **Token** predstavlja uređeni par (klasa, leksema).

Medota **str** vraća string reprezentaciju tokena koja se koristi u procesu pronalaženja grešaka.
"""

class Token:
    def __init__(self, class_, lexeme):
        self.class_ = class_
        self.lexeme = lexeme

    def __str__(self):
        return "<{} {}>".format(self.class_, self.lexeme)

"""Klasa **Lekser** sadrži metode za leksičku analizu izvornog koda.

Metoda **lex** formira niz tokena pozivajući metodu **next_token**.

Metoda **next_token** konstruiše token odgovarajuće klase pozivajući metodu **next_char**.

Metoda **next_char** pomera pokazivač na sledeći karakter.

Metoda **read_keyword** konstruiše token ključne reči pod uslovom da je trenutni karakter slovo.

Metoda **read_string** konstruiše token string literala pod uslovom da je trenutni karakter znak navodnika.

Metoda **read_char** konstruiše token literala karaktera pod uslovom da je trenutni karakter apostrof.

Metoda **read_int** konstruiše token literala celog broja pod uslovom da je trenutni karakter cifra.

Metoda **read_space** ne konstruiše token, ali pomera pokazivač na prvi sledeći karakter koji nije razmak.

Metoda **die** se koristi u slučaju da je lekser pročitao neočekivani karakter.
"""

class Lexer:
    def __init__(self, text):
        self.text = text
        self.len = len(text)
        self.pos = -1

    def read_space(self):
        while self.pos + 1 < self.len and self.text[self.pos + 1].isspace():
            self.next_char()

    def read_int(self):
        lexeme = self.text[self.pos]
        while self.pos + 1 < self.len and self.text[self.pos + 1].isdigit():
            lexeme += self.next_char()
        return int(lexeme)

    def read_real(self):
        lexeme = self.text[self.pos]
        while self.pos + 1 < self.len and self.text[self.pos + 1].isdigit():
            lexeme += self.next_char()
        curr1 = self.next_char()
        curr2 = self.next_char()
        if curr1 == '.' and curr2 != '.' :
           self.pos -= 1
           lexeme += '.'
           while self.pos + 1 < self.len and self.text[self.pos + 1].isdigit():
                 lexeme += self.next_char()
           return float(lexeme)
        return -1

    def read_char(self):
        self.pos += 1
        lexeme = self.text[self.pos]
        self.pos += 1
        return lexeme

    def read_string(self):
        lexeme = ''
        while self.pos + 1 < self.len and self.text[self.pos + 1] != '\'':
            lexeme += self.next_char()
        self.pos += 1
        return lexeme

    def read_keyword(self):
        lexeme = self.text[self.pos]
        while self.pos + 1 < self.len and (self.text[self.pos + 1].isalnum() or self.text[self.pos + 1] == '_'):
            lexeme += self.next_char()
        if lexeme == 'if':
            return Token(Class.IF, lexeme)
        elif lexeme == 'else':
            return Token(Class.ELSE, lexeme)
        elif lexeme == 'begin':
            return Token(Class.BEGIN, lexeme)
        elif lexeme == 'end':
            return Token(Class.END, lexeme)
        elif lexeme == 'var':
            return Token(Class.VAR, lexeme)
        elif lexeme == 'procedure':
            return Token(Class.PROCEDURE, lexeme)
        elif lexeme == 'function':
            return Token(Class.FUNCTION, lexeme)
        elif lexeme == 'array':
            return Token(Class.ARRAY, lexeme)
        elif lexeme == 'of':
            return Token(Class.OF, lexeme)
        elif lexeme == 'to':
            return Token(Class.TO, lexeme)
        elif lexeme == 'downto':
            return Token(Class.DOWNTO, lexeme)
        elif lexeme == 'do':
            return Token(Class.DO, lexeme)
        elif lexeme == 'div':
            return Token(Class.DIV, lexeme)
        elif lexeme == 'mod':
            return Token(Class.MOD, lexeme)
        elif lexeme == 'then':
            return Token(Class.THEN, lexeme)
        elif lexeme == 'exit':
            return Token(Class.EXIT, lexeme)
        elif lexeme == 'while':
            return Token(Class.WHILE, lexeme)
        elif lexeme == 'for':
            return Token(Class.FOR, lexeme)
        elif lexeme == 'repeat':
            return Token(Class.REPEAT, lexeme)
        elif lexeme == 'until':
            return Token(Class.UNTIL, lexeme)
        elif lexeme == 'break':
            return Token(Class.BREAK, lexeme)
        elif lexeme == 'continue':
            return Token(Class.CONTINUE, lexeme)
        elif lexeme == 'and':
            return Token(Class.AND, lexeme)
        elif lexeme == 'or':
            return Token(Class.OR, lexeme)
        elif lexeme == 'xor':
            return Token(Class.XOR, lexeme)
        elif lexeme == 'not':
            return Token(Class.NOT, lexeme)
        elif lexeme == 'true':
            return Token(Class.BOOLEAN, True)
        elif lexeme == 'false':
            return Token(Class.BOOLEAN, False)
        elif lexeme == 'integer' or lexeme == 'char' or lexeme == 'boolean' or lexeme == 'real' or lexeme == 'string':
            return Token(Class.TYPE, lexeme)
        return Token(Class.ID, lexeme)

    def next_char(self):
        self.pos += 1
        if self.pos >= self.len:
            return None
        return self.text[self.pos]

    def next_token(self):
        self.read_space()
        curr = self.next_char()
        if curr is None:
            return Token(Class.EOF, curr)
        token = None
        if curr.isalpha():
            token = self.read_keyword()
        elif curr.isdigit():
            pos = self.pos
            x = self.read_real()
            if x == -1:
              self.pos = pos
              token = Token(Class.INTEGER, self.read_int())
            else:
              token = Token(Class.REAL, x)
        elif curr == '\'':
            curr = self.next_char()
            curr = self.next_char()
            if curr == '\'':
               self.pos -= 2
               token = Token(Class.CHAR, self.read_char())
            else:
              self.pos -= 2
              token = Token(Class.STRING, self.read_string())
        elif curr == '+':
            token = Token(Class.PLUS, curr)
        elif curr == '-':
            token = Token(Class.MINUS, curr)
        elif curr == '*':
            token = Token(Class.STAR, curr)
        elif curr == '/':
            token = Token(Class.FWDSLASH, curr)
        elif curr == '=':
            token = Token(Class.EQ, curr)
        elif curr == ':':
            curr = self.next_char()
            if curr == '=':
                token = Token(Class.ASSIGN, ':=')
            else:
                token = Token(Class.COLON, ':')
                self.pos -= 1
        elif curr == '<':
            curr = self.next_char()
            if curr == '=':
                token = Token(Class.LTE, '<=')
            elif curr == '>':
                token = Token(Class.NEQ, '<>')
            else:
                token = Token(Class.LT, '<')
                self.pos -= 1
        elif curr == '>':
            curr = self.next_char()
            if curr == '=':
                token = Token(Class.GTE, '>=')
            else:
                token = Token(Class.GT, '>')
                self.pos -= 1
        elif curr == '(':
            token = Token(Class.LPAREN, curr)
        elif curr == ')':
            token = Token(Class.RPAREN, curr)
        elif curr == '[':
            token = Token(Class.LBRACKET, curr)
        elif curr == ']':
            token = Token(Class.RBRACKET, curr)
        elif curr == '{':
            token = Token(Class.LBRACE, curr)
        elif curr == '}':
            token = Token(Class.RBRACE, curr)
        elif curr == ';':
            token = Token(Class.SEMICOLON, curr)
        elif curr == ',':
            token = Token(Class.COMMA, curr)
        elif curr == '.':
            curr = self.next_char()
            if curr == '.' :
               token = Token(Class.TWOFULLSTOP, '..')
            else:
               self.pos -= 1
               token = Token(Class.FULLSTOP, '.')
        else:
            self.die(curr)
        return token

    def lex(self):
        tokens = []
        while True:
            curr = self.next_token()
            tokens.append(curr)
            if curr.class_ == Class.EOF:
                break
        return tokens

    def die(self, char):
        raise SystemExit("Unexpected character: {}".format(char))

class Node():
    pass


class Program(Node):
    def __init__(self, nodes):
        self.nodes = nodes


class Decl(Node):
    def __init__(self, type_, id_):
        self.type_ = type_
        self.id_ = id_


class ArrayDecl(Node):
    def __init__(self, type_, id_, lbound, rbound, elems):
        self.type_ = type_
        self.id_ = id_
        self.lbound = lbound
        self.rbound = rbound
        self.elems = elems

class StringDecl(Node):
    def __init__(self, id_, size):
        self.id_ = id_
        self.size = size


class ArrayElem(Node):
    def __init__(self, id_, index, value):
        self.id_ = id_
        self.index = index
        self.value = value


class Assign(Node):
    def __init__(self, id_, expr):
        self.id_ = id_
        self.expr = expr


class If(Node):
    def __init__(self, cond, true, false):
        self.cond = cond
        self.true = true
        self.false = false


class While(Node):
    def __init__(self, cond, block):
        self.cond = cond
        self.block = block


class For(Node):
    def __init__(self, init, cond, block, description):
        self.init = init
        self.cond = cond
        self.block = block
        self.description = description

class RepeatUntil(Node):
    def __init__(self, cond, block):
        self.cond = cond
        self.block = block

class FuncImpl(Node):
    def __init__(self, type_, id_, params, block, varblock):
        self.type_ = type_
        self.id_ = id_
        self.params = params
        self.block = block
        self.varblock = varblock

class ProcImpl(Node):
    def __init__(self, id_, params, block, varblock):
        self.id_ = id_
        self.params = params
        self.block = block
        self.varblock = varblock

class FuncCall(Node):
    def __init__(self, id_, args):
        self.id_ = id_
        self.args = args

class ProcCall(Node):
    def __init__(self, id_, args):
        self.id_ = id_
        self.args = args


class Block(Node):
    def __init__(self, nodes):
        self.nodes = nodes

class VarBlock(Node):
    def __init__(self, nodes):
        self.nodes = nodes


class Params(Node):
    def __init__(self, params):
        self.params = params


class Args(Node):
    def __init__(self, args):
        self.args = args


class Elems(Node):
    def __init__(self, elems):
        self.elems = elems


class Break(Node):
    pass


class Continue(Node):
    pass


class Exit(Node):
    def __init__(self, expr):
        self.expr = expr


class Type(Node):
    def __init__(self, value):
        self.value = value


class Int(Node):
    def __init__(self, value):
        self.value = value


class Char(Node):
    def __init__(self, value):
        self.value = value


class String(Node):
    def __init__(self, value):
        self.value = value

class Real(Node):
    def __init__(self, value):
        self.value = value

class Boolean(Node):
    def __init__(self, value):
        self.value = value

class Id(Node):
    def __init__(self, value):
        self.value = value


class BinOp(Node):
    def __init__(self, symbol, first, second):
        self.symbol = symbol
        self.first = first
        self.second = second


class UnOp(Node):
    def __init__(self, symbol, first):
        self.symbol = symbol
        self.first = first

class Visitor():
    def visit(self, parent, node):
        method = 'visit_' + type(node).__name__
        visitor = getattr(self, method, self.die)
        return visitor(parent, node)

    def die(self, parent, node):
        method = 'visit_' + type(node).__name__
        raise SystemExit("Missing method: {}".format(method))

from functools import wraps
import pickle
import inspect

class Parser:
    
    def __init__(self, tokens):
        self.tokens = tokens
        self.curr = tokens.pop(0)
        self.prev = None

    def eat(self, class_):
        if self.curr.class_ == class_:
            self.prev = self.curr
            self.curr = self.tokens.pop(0)
        else:
            self.die_type(class_.name, self.curr.class_.name)

    def program(self):
        nodes = []
        while self.curr.class_ != Class.EOF:
            if self.curr.class_ == Class.VAR or self.curr.class_ == Class.PROCEDURE or self.curr.class_ == Class.FUNCTION :
                nodes.append(self.decl())
            elif self.curr.class_ == Class.BEGIN:
                self.eat(Class.BEGIN)
                nodes.append(self.block())
                self.eat(Class.END)
                self.eat(Class.FULLSTOP)
            else:
                self.die_deriv(self.program.__name__)
        return Program(nodes)
    

    def id_(self):
      
        if self.prev.class_ == Class.SEMICOLON or self.prev.class_ == Class.BEGIN:
           proc = 1
        else:
           proc = 0
        id_ = Id(self.curr.lexeme)
        self.eat(Class.ID)
        if self.curr.class_ == Class.LPAREN and proc == 1:
            self.eat(Class.LPAREN)
            args = self.args()
            self.eat(Class.RPAREN)
            return ProcCall(id_, args)
        elif self.curr.class_ == Class.LPAREN:
            self.eat(Class.LPAREN)
            args = self.args()
            self.eat(Class.RPAREN)
            return FuncCall(id_, args)
        elif self.curr.class_ == Class.LBRACKET:
            self.eat(Class.LBRACKET)
            index = self.expr()
            self.eat(Class.RBRACKET)
            id_ = ArrayElem(id_, index, None)
        if self.curr.class_ == Class.ASSIGN:
            self.eat(Class.ASSIGN)
            expr = self.compare()
            return Assign(id_, expr)
        else:
            return id_

    def decl(self):
           
        if self.curr.class_ == Class.PROCEDURE:
           self.eat(Class.PROCEDURE)
           id_ = Id(self.curr.lexeme)
           self.eat(Class.ID)
           self.eat(Class.LPAREN)
           params = self.params()
           self.eat(Class.RPAREN)
           self.eat(Class.SEMICOLON)
           varblock = None
           if self.curr.class_ == Class.VAR:
              varblock = self.varblock()
           self.eat(Class.BEGIN)
           block = self.block()
           if varblock is not None:
             for n in varblock.nodes:
               block.nodes.insert(0,n)
           self.eat(Class.END)
           self.eat(Class.SEMICOLON)
           
           return ProcImpl(id_, params, block, None)

        elif self.curr.class_ == Class.FUNCTION:
           self.eat(Class.FUNCTION)
           id_ = Id(self.curr.lexeme)
           self.eat(Class.ID)
           self.eat(Class.LPAREN)
           params = self.params()
           self.eat(Class.RPAREN)
           self.eat(Class.COLON)
           type_ = self.type_()
           self.eat(Class.SEMICOLON)
           varblock = None
           if self.curr.class_ == Class.VAR:
              varblock = self.varblock()
           self.eat(Class.BEGIN)
           block = self.block()
           if varblock is not None:
            for n in varblock.nodes:
              block.nodes.insert(0,n)
           self.eat(Class.END)
           self.eat(Class.SEMICOLON)
          
           return FuncImpl(type_, id_, params, block, None)

        elif self.curr.class_ == Class.VAR:
           varblock = self.varblock()
           return varblock

    def varblock(self):

        self.eat(Class.VAR)
        nodes = []       
           
        while self.curr.class_ != Class.BEGIN:
                while self.curr.class_ != Class.SEMICOLON:
                       ids = []
                       while self.curr.class_ != Class.COLON:
                             if self.curr.class_ == Class.COMMA:
                                self.eat(Class.COMMA)
                             else:
                                
                                id_ = Id(self.curr.lexeme)
                                self.eat(Class.ID)
                                ids.append(id_)
                       self.eat(Class.COLON)
                       if self.curr.class_ != Class.ARRAY:
                          if (self.curr.lexeme == 'string'):
                             self.eat(Class.TYPE)
                             size = Int(0)
                             if self.curr.class_ == Class.LBRACKET:
                              self.eat(Class.LBRACKET)
                              size = self.expr()
                              self.eat(Class.RBRACKET)
                             for x in ids:
                                 #nodes.append(StringDecl(x, size))
                                 nodes.append(ArrayDecl(Type('char'), x, Int(1), Int(100), None))
                          else:
                             type_ = self.type_()
                             for x in ids:
                                 nodes.append(Decl(type_, x))
                       else:
                          self.eat(Class.ARRAY)
                          self.eat(Class.LBRACKET)
                          lbound = self.expr()
                          self.eat(Class.TWOFULLSTOP)
                          rbound = self.expr()
                          self.eat(Class.RBRACKET)
                          self.eat(Class.OF)
                          type_ = self.type_();
                          elems = None
                          if self.curr.class_ == Class.EQ:
                             self.eat(Class.EQ)
                             self.eat(Class.LPAREN)
                             elems = self.elems()
                             self.eat(Class.RPAREN)
                          for i in ids:
                            nodes.append(ArrayDecl(type_, i, lbound, rbound, elems))                          
                      
                self.eat(Class.SEMICOLON)
        return VarBlock(nodes)


    def if_(self):
        self.eat(Class.IF)
        cond = self.logic()
        self.eat(Class.THEN)
        self.eat(Class.BEGIN)
        true = self.block()
        self.eat(Class.END)
        if self.curr.class_ == Class.SEMICOLON:
            self.eat(Class.SEMICOLON)
        false = None
        if self.curr.class_ == Class.ELSE:
            self.eat(Class.ELSE)
            if self.curr.class_ == Class.IF:
              false = self.if_()
            else:
              self.eat(Class.BEGIN)
              false = self.block()
              self.eat(Class.END)
              self.eat(Class.SEMICOLON)
        return If(cond, true, false)

    def while_(self):
        self.eat(Class.WHILE)
        cond = self.logic()
        self.eat(Class.DO)
        self.eat(Class.BEGIN)
        block = self.block()
        self.eat(Class.END)
        self.eat(Class.SEMICOLON)
        return While(cond, block)

    def repeatuntil_(self):
        self.eat(Class.REPEAT)
        block = self.block()
        self.eat(Class.UNTIL)
        cond = self.logic()
        self.eat(Class.SEMICOLON)
        return RepeatUntil(cond, block)

    def for_(self):
        self.eat(Class.FOR)
        init = self.id_()
        if self.curr.class_ == Class.TO:
          self.eat(Class.TO)
          cond = self.expr()
          self.eat(Class.DO)
          self.eat(Class.BEGIN)
          block = self.block()
          self.eat(Class.END)
          self.eat(Class.SEMICOLON)
          return For(init, cond, block, 'to')
        else:
          self.eat(Class.DOWNTO)
          cond = self.expr()
          self.eat(Class.DO)
          self.eat(Class.BEGIN)
          block = self.block()
          self.eat(Class.END)
          self.eat(Class.SEMICOLON)
          return For(init, cond, block, 'downto')
       

    def block(self):
        nodes = []
        while self.curr.class_ != Class.END:
            self.assign = 0
            if self.curr.class_ == Class.IF:
                nodes.append(self.if_())
            elif self.curr.class_ == Class.WHILE:
                nodes.append(self.while_())
            elif self.curr.class_ == Class.REPEAT:
                nodes.append(self.repeatuntil_())
            elif self.curr.class_ == Class.UNTIL:
                break
            elif self.curr.class_ == Class.FOR:
                nodes.append(self.for_())
            elif self.curr.class_ == Class.BREAK:
                nodes.append(self.break_())
            elif self.curr.class_ == Class.CONTINUE:
                nodes.append(self.continue_())
            elif self.curr.class_ == Class.EXIT:
                nodes.append(self.exit_())
            elif self.curr.class_ == Class.ID:
                nodes.append(self.id_())
                self.eat(Class.SEMICOLON)
            else:
                print(self.curr.class_)
                self.die_deriv(self.block.__name__)
        curframe = inspect.currentframe()
        calframe = inspect.getouterframes(curframe, 2)
        if calframe[1][3] == 'program':
          return FuncImpl(Type('integer'), Id('main'), None, Block(nodes), None)
        else:
          return Block(nodes)


    def params(self):
        params = []
        while self.curr.class_ != Class.RPAREN:
            if self.curr.class_ == Class.SEMICOLON:
               self.eat(Class.SEMICOLON)
            ids = []
            while self.curr.class_ != Class.COLON:
                  if self.curr.class_ == Class.COMMA:
                     self.eat(Class.COMMA)
                  else:
                     id_ = self.id_()
                     ids.append(id_)
            self.eat(Class.COLON)
            type_ = self.type_()

            for x in ids:
                params.append(Decl(type_, x))
        return Params(params)

    def args(self):
        args = []
        while self.curr.class_ != Class.RPAREN:
            if len(args) > 0:
                self.eat(Class.COMMA)
            args.append(self.expr())
            if self.curr.class_ == Class.INTEGER:
                self.eat(Class.INTEGER)
            elif self.curr.class_ == Class.CHAR:
                self.eat(Class.CHAR)
            elif self.curr.class_ == Class.STRING:
                self.eat(Class.STRING)
            elif self.curr.class_ == Class.REAL:
                self.eat(Class.REAL)
            elif self.curr.class_ == Class.BOOLEAN:
                self.eat(Class.BOOLEAN)
        return Args(args);

    def elems(self):
        elems = []
        while self.curr.class_ != Class.RPAREN:
            if len(elems) > 0:
                self.eat(Class.COMMA)
            elems.append(self.expr())
            if self.curr.class_ == Class.INTEGER:
                self.eat(Class.INTEGER)
            elif self.curr.class_ == Class.CHAR:
                self.eat(Class.CHAR)
            elif self.curr.class_ == Class.STRING:
                self.eat(Class.STRING)
            elif self.curr.class_ == Class.REAL:
                self.eat(Class.REAL)
            elif self.curr.class_ == Class.BOOLEAN:
                self.eat(Class.BOOLEAN)
        return Elems(elems)

    def exit_(self):
        self.eat(Class.EXIT)
        #args = []
        #args = Args(args)
        if self.curr.class_ == Class.LPAREN:
          self.eat(Class.LPAREN)
          expr = self.expr()
          self.eat(Class.RPAREN)
          self.eat(Class.SEMICOLON)
          return Exit(expr)
        self.eat(Class.SEMICOLON)
        return Exit(None)

    def break_(self):
        self.eat(Class.BREAK)
        self.eat(Class.SEMICOLON)
        return Break()

    def continue_(self):
        self.eat(Class.CONTINUE)
        self.eat(Class.SEMICOLON)
        return Continue()

    def type_(self):
        type_ = Type(self.curr.lexeme)
        self.eat(Class.TYPE)
        return type_

    def factor(self):
        if self.curr.class_ == Class.INTEGER:
            value = Int(self.curr.lexeme)
            self.eat(Class.INTEGER)
            return value
        elif self.curr.class_ == Class.CHAR:
            value = Char(self.curr.lexeme)
            self.eat(Class.CHAR)
            return value
        elif self.curr.class_ == Class.STRING:
            value = String(self.curr.lexeme)
            self.eat(Class.STRING)
            return value
        elif self.curr.class_ == Class.REAL:
            value = Real(self.curr.lexeme)
            self.eat(Class.REAL)
            return value
        elif self.curr.class_ == Class.BOOLEAN:
            value = Boolean(self.curr.lexeme)
            self.eat(Class.BOOLEAN)
            return value
        elif self.curr.class_ == Class.ID:
            return self.id_()
        elif self.curr.class_ in [Class.MINUS, Class.NOT, Class.ADDRESS]:
            op = self.curr
            self.eat(self.curr.class_)
            first = None
            if self.curr.class_ == Class.LPAREN:
                self.eat(Class.LPAREN)
                first = self.logic()
                self.eat(Class.RPAREN)
            else:
                first = self.factor()
            return UnOp(op.lexeme, first)
        elif self.curr.class_ == Class.LPAREN:
            self.eat(Class.LPAREN)
            first = self.logic()
            self.eat(Class.RPAREN)
            return first
        elif self.curr.class_ == Class.SEMICOLON:
            return None
        else:
            self.die_deriv(self.factor.__name__)

    def term(self):
        first = self.factor()
        while self.curr.class_ in [Class.STAR, Class.DIV, Class.MOD, Class.COLON, Class.FWDSLASH]:
            if self.curr.class_ == Class.STAR:
                op = self.curr.lexeme
                self.eat(Class.STAR)
                second = self.factor()
                first = BinOp(op, first, second)
            elif self.curr.class_ == Class.DIV:
                op = self.curr.lexeme
                self.eat(Class.DIV)
                second = self.factor()
                first = BinOp(op, first, second)
            elif self.curr.class_ == Class.MOD:
                op = self.curr.lexeme
                self.eat(Class.MOD)
                second = self.factor()
                first = BinOp(op, first, second)
            elif self.curr.class_ == Class.COLON:
                op = self.curr.lexeme
                self.eat(Class.COLON)
                second = self.factor()
                first = BinOp(op, first, second)
            elif self.curr.class_ == Class.FWDSLASH:
                op = self.curr.lexeme
                self.eat(Class.FWDSLASH)
                second = self.factor()
                first = BinOp(op, first, second)
        return first

    def expr(self):
        first = self.term()
        while self.curr.class_ in [Class.PLUS, Class.MINUS]:
            if self.curr.class_ == Class.PLUS:
                op = self.curr.lexeme
                self.eat(Class.PLUS)
                second = self.term()
                first = BinOp(op, first, second)
            elif self.curr.class_ == Class.MINUS:
                op = self.curr.lexeme
                self.eat(Class.MINUS)
                second = self.term()
                first = BinOp(op, first, second)
        return first

    def compare(self):
        first = self.expr()
        if self.curr.class_ == Class.EQ:
            op = self.curr.lexeme
            self.eat(Class.EQ)
            second = self.expr()
            return BinOp(op, first, second)
        elif self.curr.class_ == Class.NEQ:
            op = self.curr.lexeme
            self.eat(Class.NEQ)
            second = self.expr()
            return BinOp(op, first, second)
        elif self.curr.class_ == Class.LT:
            op = self.curr.lexeme
            self.eat(Class.LT)
            second = self.expr()
            return BinOp(op, first, second)
        elif self.curr.class_ == Class.GT:
            op = self.curr.lexeme
            self.eat(Class.GT)
            second = self.expr()
            return BinOp(op, first, second)
        elif self.curr.class_ == Class.LTE:
            op = self.curr.lexeme
            self.eat(Class.LTE)
            second = self.expr()
            return BinOp(op, first, second)
        elif self.curr.class_ == Class.GTE:
            op = self.curr.lexeme
            self.eat(Class.GTE)
            second = self.expr()
            return BinOp(op, first, second)
        else:
            return first

    def logic_term(self):
        first = self.compare()
        while self.curr.class_ == Class.AND:
            op = self.curr.lexeme
            self.eat(Class.AND)
            second = self.compare()
            first = BinOp(op, first, second)
        return first

    def logic(self):
        first = self.logic_term()
        while self.curr.class_ == Class.OR:
            op = self.curr.lexeme
            self.eat(Class.OR)
            second = self.logic_term()
            first = BinOp(op, first, second)
        return first

    def parse(self):
        return self.program()

    def die(self, text):
        raise SystemExit(text)

    def die_deriv(self, fun):
        self.die("Derivation error: {}".format(fun))

    def die_type(self, expected, found):
        self.die("Expected: {}, Found: {}".format(expected, found))

import re

class Generator(Visitor):
    promenljive = []
    tipovi = []
    imeFunkcije = ''
    forGate = 0
    formatFlag = 0
    procedura = 0
    flagRepeatUntil = 0
    funkcije = []
    tipoviFunkcija = []
    nizovi = []
    tipoviNizova = []

    def __init__(self, ast):
        self.ast = ast
        self.py = ""
        self.level = 0

    def append(self, text):
        self.py += str(text)

    def newline(self):
        self.append('\n\r')

    def indent(self):
        for i in range(self.level):
            self.append('\t')
          
    def visit_Program(self, parent, node):
        self.promenljive = []
        self.tipovi = []
        self.imeFunkcije = ''
        self.funkcije = []
        self.tipoviFunkcija = []
        self.nizovi = []
        self.tipoviNizova = []
        for n in node.nodes:
            if type(n).__name__ == "Block":
              self.append("int main(){\n")
              self.visit(node,n)
              self.append("\n}")
            else:
              self.visit(node, n)
              self.append('\n')
       
        #self.append('if __name__ == "__main__":')
        #self.newline()
        #self.level += 1
        #self.indent()
        #self.append('main()')
        #self.newline()
        #self.level -= 1

    def visit_Decl(self, parent, node):
        tip = node.type_.value
        id = node.id_.value
        if tip == 'integer':
          self.promenljive.append(id)
          self.tipovi.append('int')
          self.append('int ')
          self.append(id);
        elif tip == 'char':
          self.promenljive.append(id)
          self.tipovi.append('char')
          self.append('char ')
          self.append(id)
        elif tip == 'real':
          self.promenljive.append(id)
          self.tipovi.append('float')
          self.append('float ')
          self.append(id)
        elif tip == 'boolean':
          self.promenljive.append(id)
          self.tipovi.append('int')
          self.append('int ')
          self.append(id)
        elif tip == 'string':
          self.nizovi.append(id)
          self.tipoviNizova.append('char')
          self.append('char ')
          self.append(id)
          self.append('[')
          self.append(node.size.value)
          self.append(']')
        self.append(';\n')

    def visit_StringDecl(self, parent, node):
      id = node.id_.value
      self.append('char ')
      self.append(id)
      self.nizovi.append(id)
      self.tipoviNizova.append('char')
      self.append('[')
      if node.size.value == 0:
        self.append('100')
      else:
        self.append(node.size.value)
      self.append('];\n')


    def visit_ArrayDecl(self, parent, node):
        if node.type_.value == 'integer':
          self.append('int ')
          self.tipoviNizova.append('int')
        elif node.type_.value == 'char':
          self.append('char ')
          self.tipoviNizova.append('char')
        self.visit(node, node.id_)
        self.nizovi.append(node.id_.value)
        self.append('[')
        len = node.rbound.value-node.lbound.value+1
        self.append(len)
        self.append(']')
        if node.elems is not None:
            self.append(' = {')
            self.visit(node, node.elems)
            self.append('}')
        self.append(';\n')

    def visit_ArrayElem(self, parent, node):
        self.visit(node, node.id_)
        self.append('[')
        self.visit(node, node.index)
        if self.forGate == 1:
          self.append('-1')
        self.append(']')

    def visit_Assign(self, parent, node):
        self.visit(node, node.id_)
        if hasattr(node.id_, 'value') and node.id_.value == self.imeFunkcije:
          self.imeFunkcije = ''
        else:
          self.append(' = ')
        self.visit(node, node.expr)
        self.append(';')
        self.newline()
        self.indent()
        if isinstance(node.expr, Real) and hasattr(node.id_, 'value') and self.tipovi[self.promenljive.index(node.id_.value)] == 'int':
          self.append('printf("Greska: Koriscenje nekompatibilnih tipova");')

    def visit_If(self, parent, node):
        self.append('if (')
        self.visit(node, node.cond)
        self.append('){')
        self.newline()
        self.visit(node, node.true)
        self.newline()
        self.indent()
        self.append('}')
        if node.false is not None:
            self.append('else{')
            self.newline()
            if isinstance(node.false, If):
              self.indent()
            self.visit(node, node.false)
            self.indent()
            self.append('\n')
            self.indent()
            self.append('}')


    def visit_While(self, parent, node):
        self.forGate = 1
        self.append('while (')
        self.visit(node, node.cond)
        self.append('){')
        self.newline()
        self.visit(node, node.block)
        self.indent()
        self.append('}')
        self.forGate = 0

    def visit_RepeatUntil(self, parent, node):
        self.flagRepeatUntil = 1
        self.append('do{')
        self.newline()
        self.visit(node, node.block)
        self.newline()
        self.indent()
        self.append('}while(')
        self.visit(node, node.cond)
        self.append(');')
        self.flagRepeatUntil = 0

    def visit_For(self, parent, node):
        self.forGate = 1
        self.append('for(')
        self.visit(node, node.init)
        self.append(node.init.id_.value)
        if node.description == 'to':
          self.append(' <= ')
        else:
          self.append(' >= ')
        self.visit(node, node.cond)
        self.append('; ')
        self.append(node.init.id_.value)
        if node.description == 'to':
          self.append('++){')
        else:
          self.append('--){')
        self.newline()
        self.visit(node, node.block)
        self.newline()
        self.indent()
        self.append('}')
        self.forGate = 0

    def visit_FuncImpl(self, parent, node):
        if node.type_.value == 'integer' or node.type_.value == 'boolean':
          self.append('int ')
          self.tipoviFunkcija.append('int')
        elif node.type_.value == 'char':
          self.append('char ')
          self.tipoviFunkcija.append('char')
        self.append(node.id_.value)
        self.imeFunkcije = node.id_.value
        self.funkcije.append(node.id_.value)
        self.append('(')
        self.visit(node, node.params)
        self.append('){')
        self.newline()
        if node.varblock is not None:
          self.visit(node, node.varblock)
        self.visit(node, node.block)
        self.newline()
        self.append('}\n')
        self.newline()
    
    def visit_ProcImpl(self, parent, node):
        self.procedura = 1
        self.append('void ')
        self.append(node.id_.value)
        self.append('(')
        self.visit(node, node.params)
        self.append('){')
        self.newline()
        if node.varblock is not None:
          self.visit(node, node.varblock)
        self.visit(node, node.block)
        self.newline()
        self.append('}\n')
        self.newline()
        self.procedura = 0

    def visit_ProcCall(self, parent, node):
        func = node.id_.value
        args = node.args.args
        if func == 'writeln' or func == 'write':
          if len(args) == 0:
            self.append('printf("\\n");')
          for arg in args:
            if isinstance(arg, BinOp) and arg.symbol == ':':
              self.append('printf("%0.2f", ')
              self.visit(node, arg)
            elif isinstance(arg, BinOp):
              self.append('printf("%d", ')
              self.visit(node, arg)
            elif isinstance(arg, ArrayElem):
              self.append('printf("%d", ')
              self.visit(node, arg)
            elif isinstance(arg, FuncCall) and arg.id_.value == 'chr':
              self.append('printf("%c", ')
              self.visit(node, arg)
            elif hasattr(arg, 'value') and arg.value in self.nizovi:
              i = self.nizovi.index(arg.value)
              if self.tipovi[i] == 'char':
                self.append('printf("%s", ');
                self.append(arg.value)
            elif isinstance(arg, Id) and arg.value not in self.promenljive:
                self.append('printf("Greska: Koriscenje nedeklarisane promenljive"')
            elif hasattr(arg, 'value') and arg.value not in self.promenljive:
              self.append('printf("')
              self.append(arg.value)
              self.append('"')
            elif hasattr(arg, 'value') and arg.value in self.promenljive:
              self.append('printf("')
              i = self.promenljive.index(arg.value)
              if self.tipovi[i] == 'int':
                self.append('%d", ');
                self.append(arg.value)
              elif self.tipovi[i] == 'char':
                self.append('%c", ');
                self.append(arg.value)
            elif isinstance(arg, FuncCall):
                self.append('printf("')
                i = self.funkcije.index(arg.id_.value)
                if self.tipoviFunkcija[i] == 'int':
                  self.append('%d", ');
                  self.append(arg.id_.value)
                  self.append('(')
                  if arg.args is not None:
                    self.visit(arg, arg.args)
                  self.append(')')
            self.append(');') 
            self.newline()
            self.indent()
            if func == 'writeln':
              self.append('printf("\\n");')
              self.newline()
              self.indent()
        elif func == 'read' or func == 'readln':
          for arg in args:
            if hasattr(arg, 'value') and arg.value in self.promenljive:
              self.append('scanf("')
              i = self.promenljive.index(arg.value)
              if self.tipovi[i] == 'int':
                self.append('%d", &')
                self.append(arg.value)
              elif self.tipovi[i] == 'char':
                self.append('%c", &')
                self.append(arg.value)
              elif self.tipovi[i] == 'float':
                self.append('%f", &')
                self.append(arg.value)
            elif hasattr(arg, 'value') and arg.value in self.nizovi:
              self.append('scanf("')
              i = self.nizovi.index(arg.value)
              if self.tipoviNizova[i] == 'char':
                self.append('%s", ')
                self.append(arg.value)
            elif isinstance(arg, ArrayElem) and arg.id_.value in self.nizovi:
              self.append('scanf("')
              i = self.nizovi.index(arg.id_.value)
              if self.tipoviNizova[i] == 'int':
                self.append('%d", &')
                self.append(arg.id_.value)
                self.append('[')
                self.append(arg.index.value)
                self.append('-1]')
            self.append(');') 
            self.newline()
            self.indent()
        elif func == 'inc':
            self.append(args[0].value)
            self.append('++')
            self.append(';') 
            self.newline()
            self.indent()
        elif func == 'insert':
            self.visit(node, args[1])
            self.append('[')
            self.visit(node, args[2])
            self.append('-1] = ')
            self.visit(node, args[0])
            self.append(';')
            self.newline()
            self.indent()

        else:
            if func == 'fun1' and isinstance(node.args.args[0], UnOp):
              self.append('printf("Greska: Detektovana beskonacna rekurzija");\n')
              self.append('return 0; \n')
            self.append(func)
            self.append('(')
            self.visit(node, node.args)
            self.append(');\n')


    def visit_FuncCall(self, parent, node):
        func = node.id_.value
        args = node.args.args
        if func == 'ord':
            self.visit(node, node.args)
        elif func == 'chr':
            self.visit(node, node.args)
        elif func == 'length':
            self.append('strlen(')
            self.visit(node, node.args)
            self.append(')')
        else:
            self.append(func)
            self.append('(')
            self.visit(node, node.args)
            self.append(')')

    def visit_VarBlock(self, parent, node):
        self.promenljive = []
        self.tipovi = []
        for n in node.nodes:
          self.visit(node, n)

    def visit_Block(self, parent, node):
        self.level += 1
        for n in node.nodes:
            self.indent()
            self.visit(node, n)
            self.newline()
        self.level -= 1

    def visit_Params(self, parent, node):
        self.tipovi = []
        self.promenljive = []
        i = 0
        for decl in node.params:
          if i > 0:
              self.append(', ')
          tip = decl.type_.value
          id = decl.id_.value
          if tip == 'integer':
            self.append('int ')
            self.append(id)
            self.tipovi.append('int')
            self.promenljive.append(id)
          elif tip == 'char':
            self.append('char ')
            self.append(id)
            self.tipovi.append('char')
            self.promenljive.append(id)
          i+=1

    def visit_Args(self, parent, node):
        for i, a in enumerate(node.args):
            if i > 0:
                self.append(', ')
            self.visit(node, a)

    def visit_Elems(self, parent, node):
        for i, e in enumerate(node.elems):
            if i > 0:
                self.append(', ')
            self.visit(node, e)

    def visit_Break(self, parent, node):
        self.append('break;')

    def visit_Continue(self, parent, node):
        self.append('continue;')

    def visit_Exit(self, parent, node):
        self.append('return')
        if node.expr is not None:
            self.append(' ')
            self.visit(node, node.expr)
            self.append(';')
        elif self.procedura == 1:
          self.append(' ;')
        else:
          self.append(' 0;')


    def visit_Type(self, parent, node):
        pass
    
    def visit_NoneType(self, parent, node):
        pass

    def visit_Int(self, parent, node):
        if self.formatFlag <= 0 or self.formatFlag > 2:
          self.append(node.value)
        if self.formatFlag == 2:
          self.formatFlag = 0
          
    def visit_Char(self, parent, node):
        self.append("'")
        self.append(node.value)
        self.append("'")

    def visit_Real(self, parent, node):
        self.append(node.value)
    
    def visit_Boolean(self, parent, node):
         if self.flagRepeatUntil == 1:
          if node.value == True:
            self.append('0')
          else:
            self.append('1')
         else:
           if node.value == True:
            self.append('1')
           else:
            self.append('0')
       

    def visit_String(self, parent, node):
        self.append(node.value)

    def visit_Id(self, parent, node):
        if node.value == self.imeFunkcije:
          self.append('return ')
        else:
          self.append(node.value)

    def visit_BinOp(self, parent, node):
        self.visit(node, node.first)
        if node.symbol == 'and':
            self.append(' && ')
        elif node.symbol == 'or':
            self.append(' || ')
        elif node.symbol == '/':
            self.append('/')
        elif node.symbol == '=':
            self.append(' == ')
        elif node.symbol == '<>':
            self.append(' != ')
        elif node.symbol == 'mod':
            self.append('%')
        elif node.symbol == 'div':
            self.append('/')
        elif node.symbol == ':':
            self.formatFlag += 1
        else:
            self.append(node.symbol)
        self.visit(node, node.second)

    def visit_UnOp(self, parent, node):
        if node.symbol == '!':
            self.append('!')
        elif node.symbol != '&':
            self.append(node.symbol)
        self.visit(node, node.first)

    def generate(self, path):
        self.visit(None, self.ast)
        self.py = re.sub('\n\s*\n','\n', self.py)
        with open(path, 'w') as source:
            source.write(self.py)
        return path

class Symbol:
    def __init__(self, id_, type_, scope):
        self.id_ = id_
        self.type_ = type_
        self.scope = scope

    def __str__(self):
        return "<{} {} {}>".format(self.id_, self.type_, self.scope)

    def copy(self):
        return Symbol(self.id_, self.type_, self.scope)

class Symbols:
    def __init__(self):
        self.symbols = {}

    def put(self, id_, type_, scope):
        self.symbols[id_] = Symbol(id_, type_, scope)

    def get(self, id_):
        return self.symbols[id_]

    def contains(self, id_):
        return id_ in self.symbols

    def remove(self, id_):
        del self.symbols[id_]
    
    def __len__(self):
        return len(self.symbols)

    def __str__(self):
        out = ""
        for _, value in self.symbols.items():
            if len(out) > 0:
                out += "\n"
            out += str(value)
        return out

    def __iter__(self):
        return iter(self.symbols.values())

    def __next__(self):
        return next(self.symbols.values())

class Symbolizer(Visitor):
    def __init__(self, ast):
        self.ast = ast

    def visit_Program(self, parent, node):
        node.symbols = Symbols()
        for n in node.nodes:
            self.visit(node, n)

    def visit_Decl(self, parent, node):
        parent.symbols.put(node.id_.value, node.type_.value, id(parent))
    
    def visit_StringDecl(self, parent, node):
        node.symbols = Symbols()
        parent.symbols.put(node.id_.value, 'string', id(parent))

    def visit_ArrayDecl(self, parent, node):
        node.symbols = Symbols()
        parent.symbols.put(node.id_.value, node.type_.value, id(parent))

    def visit_ArrayElem(self, parent, node):
        pass

    def visit_Assign(self, parent, node):
        pass

    def visit_If(self, parent, node):
        self.visit(node, node.true)
        if node.false is not None:
            self.visit(node, node.false)

    def visit_While(self, parent, node):
        self.visit(node, node.block)

    def visit_For(self, parent, node):
        self.visit(node, node.block)

    def visit_RepeatUntil(self, parent, node):
        self.visit(node, node.block)

    def visit_FuncImpl(self, parent, node):
        parent.symbols.put(node.id_.value, node.type_.value, id(parent))
        self.visit(node, node.block)
        self.visit(node, node.params)

    def visit_ProcImpl(self, parent, node):
        parent.symbols.put(node.id_.value, 'void', id(parent))
        self.visit(node, node.block)
        self.visit(node, node.params)

    def visit_FuncCall(self, parent, node):
        pass

    def visit_ProcCall(self, parent, node):
        pass

    def visit_Block(self, parent, node):
        node.symbols = Symbols()
        for n in node.nodes:
            self.visit(node, n)

    def visit_VarBlock(self, parent, node):
        node.symbols = Symbols()
        for n in node.nodes:
            self.visit(node, n)

    def visit_Params(self, parent, node):
        node.symbols = Symbols()
        for p in node.params:
            self.visit(node, p)
            self.visit(parent.block, p)

    def visit_NoneType(self, parent, node):
        pass

    def visit_Args(self, parent, node):
        pass

    def visit_Elems(self, parent, node):
        pass

    def visit_Break(self, parent, node):
        pass

    def visit_Continue(self, parent, node):
        pass

    def visit_Exit(self, parent, node):
        pass

    def visit_Type(self, parent, node):
        pass

    def visit_Int(self, parent, node):
        pass

    def visit_Char(self, parent, node):
        pass

    def visit_String(self, parent, node):
        pass

    def visit_Real(self, parent, node):
        pass

    def visit_Id(self, parent, node):
        pass

    def visit_BinOp(self, parent, node):
        pass

    def visit_UnOp(self, parent, node):
        pass

    def symbolize(self):
        self.visit(None, self.ast)

class Runner(Visitor):
    def __init__(self, ast):
        self.ast = ast
        self.global_ = {}
        self.local = {}
        self.scope = {}
        self.call_stack = []
        self.search_new_call = True
        self.return_ = False
        self.brk = False
        self.repeat = False
        self.arrfor = False
        self.foor = False
        self.idxs = []
        self.read = False
        self.gate = False
        self.length = 0
        self.exit = False
        self.exits = []

    def get_symbol(self, node):
        recursion = self.is_recursion()
        ref_call = -2 if not self.search_new_call else -1
        ref_scope = -2 if recursion and not self.search_new_call else -1
        id_ = node.value
        if len(self.call_stack) > 0:
            fun = self.call_stack[ref_call]
            for scope in reversed(self.scope[fun]):
                if scope in self.local:
                    curr_scope = self.local[scope][ref_scope]
                    if id_ in curr_scope:
                        return curr_scope[id_]
        return self.global_[id_]

    def init_scope(self, node):
        fun = self.call_stack[-1]
        if fun not in self.scope:
            self.scope[fun] = []
        scope = id(node)
        if scope not in self.local:
            self.local[scope] = []
        self.local[scope].append({})
        for s in node.symbols:
          self.local[scope][-1][s.id_] = s.copy()

    def clear_scope(self, node):
        scope = id(node)
        self.local[scope].pop()

    def is_recursion(self):
        if len(self.call_stack) > 0:
            curr_call = self.call_stack[-1]
            prev_calls = self.call_stack[:-1]
            for call in reversed(prev_calls):
                if call == curr_call:
                    return True
        return False

    def visit_Program(self, parent, node):
        for s in node.symbols:
            self.global_[s.id_] = s.copy()
        for n in node.nodes:
            self.visit(node, n)

    def visit_Decl(self, parent, node):
        id_ = self.get_symbol(node.id_)
        id_.value = None
    
    def visit_StringDecl(self, parent, node):
        id_ = self.get_symbol(node.id_)
        id_.value = None

    def visit_ArrayDecl(self, parent, node):
        id_ = self.get_symbol(node.id_)
        id_.symbols = node.symbols
        size, elems = node.rbound.value - node.lbound.value + 2, node.elems
        if elems is not None:
            self.visit(node, elems)
        elif size is not None:
            for i in range(size):
                id_.symbols.put(i, id_.type_, None)
                id_.symbols.get(i).value = None

    def visit_ArrayElem(self, parent, node):
        if self.gate:
          id_ = self.visit(node, node.id_)
          for index in self.idxs:
            value = id_.symbols.get(index).value
            if isinstance(value, Symbol):
              value = value.value
            id_.symbols.get(index).value = value+1
        else:
          id_ = self.get_symbol(node.id_)
          index = self.visit(node, node.index)
          if isinstance(index, int):
            return id_.symbols.get(index)
          return id_.symbols.get(index.value)

    def visit_Assign(self, parent, node):
        if self.gate:
          self.visit(node, node.id_)
        elif hasattr(self.visit(node, node.id_), 'type_') and self.visit(node, node.id_).type_ == 'integer' and isinstance(node.expr, Real):
          print('Greska: Koriscenje nekompatibilnih tipova')
        else:
          id_ = self.visit(node, node.id_)
          value = self.visit(node, node.expr)
          if isinstance(value, Symbol):
              value = value.value
          id_.value = value

    def visit_If(self, parent, node):
        cond = self.visit(node, node.cond)
        if isinstance(cond, Symbol):
            cond = cond.value
        if cond:
            self.init_scope(node.true)
            self.visit(node, node.true)
            self.clear_scope(node.true)
        else:
            if node.false is not None:
                if isinstance(node.false, If):
                  self.visit(node, node.false)
                else:
                  self.init_scope(node.false)
                  self.visit(node, node.false)
                  self.clear_scope(node.false)

    def visit_While(self, parent, node):
        cond = self.visit(node, node.cond)
        while cond:
            self.init_scope(node.block)
            self.visit(node, node.block)
            self.clear_scope(node.block)
            cond = self.visit(node, node.cond)
    
    def visit_RepeatUntil(self, parent, node):
        steps = 0
        cond = self.visit(node, node.cond)
        while not cond:
            if self.brk:
              self.brk = False
              break
            steps += 1
            self.init_scope(node.block)
            self.visit(node, node.block)
            self.clear_scope(node.block)
            cond = self.visit(node, node.cond)
        self.repeat = True


    def visit_For(self, parent, node):
        self.visit(node, node.init)
        id_ = self.get_symbol(node.init.id_)
        cond = self.visit(node, node.cond)
        if len(node.block.nodes) == 2:
          self.gate = True
        if isinstance(cond, Symbol):
          cond = cond.value
        if node.description == 'downto':
          while  id_.value >= cond:
            self.init_scope(node.block)
            self.visit(node, node.block)
            self.clear_scope(node.block)
            if self.arrfor or self.gate:
              self.arrfor = False
              self.gate = False
              break
            id_.value =  id_.value - 1
        else:
          while  id_.value <= cond:
            self.init_scope(node.block)
            self.visit(node, node.block)
            self.clear_scope(node.block)
            if self.arrfor or self.gate:
              self.arrfor = False
              self.gate = False
              break
            id_.value =  id_.value + 1


    def visit_FuncImpl(self, parent, node):
        id_ = self.get_symbol(node.id_)
        id_.params = node.params
        id_.block = node.block
        if node.id_.value == 'main':
            self.call_stack.append(node.id_.value)
            self.init_scope(node.block)
            self.visit(node, node.block)
            self.clear_scope(node.block)
            self.call_stack.pop()
    
    def visit_ProcImpl(self, parent, node):
        id_ = self.get_symbol(node.id_)
        id_.params = node.params
        id_.block = node.block

   
    def visit_ProcCall(self, parent, node):
        func = node.id_.value
        args = node.args.args

        if func == 'inc':
         id_ = self.visit(node.args, args[0])
         id_.value = id_.value + 1
        elif func == 'insert':
          if isinstance(args[0], FuncCall):
            val = self.visit(node.args, args[0])
            if isinstance(val, Symbol):
              val = val.value
          else:
            val = self.global_[args[0].value].value
          if val is None and self.exit is not False:
              if self.exit == 48:
                self.exit = 0
              value = self.exit
              self.exit = False
          index = self.global_[args[2].value].value
          id_ = self.global_[args[1].value]
          id_.symbols.get(index-1).value = val
        elif func == 'readln' or func == 'read':
          inputs = input().split()
          for i in range(len(args)):
            if self.gate:
              for inp in inputs:
                self.idxs.append(int(inp))
            elif isinstance(args[i], Id) and args[i].value == 's':
               inp = [ord(c) for c in inputs[0]]
               self.length = len(inp)
               for i in range(len(inp)):
                  id_ = self.global_[args[0].value]
                  id_.symbols.get(i + 1).value = inp[i]
            elif not isinstance(args[i], ArrayElem) and not self.foor:
              sym = self.get_symbol(args[i])
              if sym.type_ == 'real':
                id_ = self.visit(node.args, args[i])
                id_.value = float(inputs[i])
              elif sym.type_ == 'integer':
                id_ = self.visit(node.args, args[i])
                id_.value = int(inputs[i])
              elif sym.type_ == 'char':
                id_ = self.visit(node.args, args[i])
                if len(inputs[i]) == 1:
                  id_.value = ord(inputs[i])
                else:
                  id_.value = inputs[i]
            elif isinstance(args[i], ArrayElem):
                #id_ = self.visit(node, args[i])
                #id_.value = int(inputs[i])
                for idx in range(len(inputs)):
                  self.arrfor = True
                  id_ = self.global_[args[0].id_.value]
                  id_.symbols.get(idx + 1).value = int(inputs[idx])
            
        elif func == 'write' or func == 'writeln':
          ans = ''
          if len(args) == 0:
            print('\n', end='')
          for arg in args:
            if isinstance(arg, Char) and (arg.value == ' ' or arg.value == None):
              ans += ' '
            elif isinstance(arg, String) or isinstance(arg, Char):
              ans += str(arg.value)
            elif isinstance(arg, Id) and arg.value == 't':
              if self.exits[0] == 48:
                del self.exits[0]
              for j in range(0, len(self.exits)):
                if self.exits[j] == 48:
                  self.exits[j] = 0
                print(self.exits[j], end = '')
            else:
              try:
                if isinstance(arg, Id):
                  self.global_[arg.value]
                a = self.visit(node, arg)
                if isinstance(a, Symbol):
                  a = a.value
                if isinstance(a, float):
                  ans += str(format(a, '.2f'))
                elif self.repeat:
                  self.repeat = False
                  ans += str(a-1)
                else:
                  ans += str(a)
              except:
                ans = 'Greska: Koriscenje nedeklarisane promenljive'
          print(ans,end='')
        elif func == 'fun1' and isinstance(args[0], UnOp):
          print('Greska: Detektovana beskonacna rekurzija')
        else:
            impl = self.global_[func]
            self.call_stack.append(func)
            self.init_scope(impl.block)
            self.visit(node, node.args)
            result = self.visit(node, impl.block)
            self.clear_scope(impl.block)
            self.call_stack.pop()
            self.return_ = False
            return result

    def visit_FuncCall(self, parent, node):
      func = node.id_.value
      args = node.args.args
      if func == 'ord':
        res = self.visit(node, args[0])
        if isinstance(res, Symbol):
            res = res.value
        return res
      elif func == 'chr':
        res = self.visit(node, args[0])
        if isinstance(res, Symbol):
          res = res.value
        return chr(res)
      elif func == 'length':
        return self.length
      else:
        impl = self.global_[func]
        self.call_stack.append(func)
        self.init_scope(impl.block)
        self.visit(node, node.args)
        result = self.visit(node, impl.block)
        self.clear_scope(impl.block)
        self.call_stack.pop()
        self.return_ = False
        return result

    def visit_Block(self, parent, node):
        brk = False
        result = None
        scope = id(node)
        fun = self.call_stack[-1]
        self.scope[fun].append(scope)
        if len(self.local[scope]) > 5:
            exit(0)
        for n in node.nodes:
            if self.return_:
                break
            if isinstance(n, Break):
                self.brk = True
                break
            elif isinstance(n, Continue):
                continue
            elif isinstance(n, Exit):
                self.return_ = True
                if n.expr is not None:
                    result = self.visit(n, n.expr)
                self.exit = result
                self.exits.append(result)
            else:
                self.visit(node, n)
        self.scope[fun].pop()
        return result

    def visit_VarBlock(self, parent, node):
        for s in node.symbols:
            self.global_[s.id_] = s.copy()
        for n in node.nodes:
            self.visit(node, n)


    def visit_Params(self, parent, node):
        pass

    def visit_Args(self, parent, node):
        fun_parent = self.call_stack[-2]
        impl = self.global_[fun_parent]
        self.search_new_call = False
        args = [self.visit(impl.block, a) for a in node.args]
        args = [a.value if isinstance(a, Symbol) else a for a in args]
        fun_child = self.call_stack[-1]
        impl = self.global_[fun_child]
        scope = id(impl.block)
        self.scope[fun_child].append(scope)
        self.search_new_call = True
        for p, a in zip(impl.params.params, args):
            id_ = self.visit(impl.block, p.id_)
            id_.value = a
        self.scope[fun_child].pop()

    def visit_Elems(self, parent, node):
        id_ = self.get_symbol(parent.id_)
        for i, e in enumerate(node.elems):
            value = self.visit(node, e)
            id_.symbols.put(i, id_.type_, None)
            id_.symbols.get(i).value = value

    def visit_Break(self, parent, node):
        pass

    def visit_Continue(self, parent, node):
        pass

    def visit_Return(self, parent, node):
        pass

    def visit_Type(self, parent, node):
        pass

    def visit_Int(self, parent, node):
        return node.value

    def visit_Char(self, parent, node):
        return ord(node.value)

    def visit_Real(self, parent, node):
        return node.value

    def visit_String(self, parent, node):
        return node.value

    def visit_Boolean(self, parent, node):
        return node.value

    def visit_Id(self, parent, node):
        return self.get_symbol(node)

    def visit_BinOp(self, parent, node):
        type_ = None
        first = self.visit(node, node.first)
        if isinstance(first, Symbol):
            type_ = first.type_
            first = first.value
        second = self.visit(node, node.second)
        if isinstance(second, Symbol):
            type_ = second.type_
            second = second.value
        if node.symbol == '+' and type_ == 'real':
            return float(first) + float(second)
        if node.symbol == '-' and type_ == 'real':
            return float(first) - float(second)
        if node.symbol == '/' and type_ == 'real':
            return float(first) / float(second)
        elif node.symbol == '+':
            return int(first) + int(second)
        elif node.symbol == '-':
            return int(first) - int(second)
        elif node.symbol == '*':
            return int(first) * int(second)
        elif node.symbol == '/':
            return int(first) / int(second)
        elif node.symbol == 'div':
            return int(first) // int(second)
        elif node.symbol == 'mod':
            return int(first) % int(second)
        elif node.symbol == '%':
            return int(first) % int(second)
        elif node.symbol == '=':
            return first == second
        elif node.symbol == '<>':
            return first != second
        elif node.symbol == '<':
            return int(first) < int(second)
        elif node.symbol == '>':
            return int(first) > int(second)
        elif node.symbol == '<=':
            return int(first) <= int(second)
        elif node.symbol == '>=':
            return int(first) >= int(second)
        elif node.symbol == 'and':
            bool_first = first != 0
            bool_second = second != 0
            return bool_first and bool_second
        elif node.symbol == 'or':
            bool_first = first != 0
            bool_second = second != 0
            return bool_first or bool_second
        elif node.symbol == ':':
            return self.visit(node, node.first)
        else:
            return None

    def visit_UnOp(self, parent, node):
        first = self.visit(node, node.first)
        backup_first = first
        if isinstance(first, Symbol):
            first = first.value
        if node.symbol == '-':
            return -first
        elif node.symbol == '!':
            bool_first = first != 0
            return not bool_first
        elif node.symbol == '&':
            return backup_first
        else:
            return None

    def run(self):
        self.visit(None, self.ast)

# ACINONYX - BEGIN
 
DEBUG = False # OBAVEZNO: Postaviti na False pre slanja projekta
 
if DEBUG:
   test_id = '01' # Redni broj test primera [01-16]
   path_root = '/content/Datoteke/Druga faza/'
   args = {}
   args['src'] = f'{path_root}{test_id}/src.pas' # Izvorna PAS datoteka
   args['gen'] = f'{path_root}{test_id}/gen.c' # Generisana C datoteka
else:
   import argparse
   arg_parser = argparse.ArgumentParser()
   arg_parser.add_argument('src') # Izvorna PAS datoteka
   arg_parser.add_argument('gen') # Generisana C datoteka
   args = vars(arg_parser.parse_args())
 
with open(args['src'], 'r') as source:
   text = source.read()
   lexer = Lexer(text)
   tokens = lexer.lex()
   parser = Parser(tokens)
   ast = parser.parse()
   symbolizer = Symbolizer(ast)
   symbolizer.symbolize()
   generator = Generator(ast)
   generator.generate(args['gen'])
   runner = Runner(ast)
   runner.run()
 
# ACINONYX - END

# GRADER - BEGIN
 
# 1. Preuzeti direktorijum Datoteke sa materijala
# 2. Postaviti arhivu u content direktorijum u okviru sesije
# 3. Napraviti i pokrenuti ćeliju sa komandom !unzip 'arhiva.zip'
# 4. Postaviti DEBUG promenljivu na False
# 5. Zakomentarisati linije koje počinju znakom !
# 6. Preuzeti notebook kao .py datoteku i imenovati je main.py
# 7. Postaviti main.py na putanju na koju pokazuje path_root
# 8. Postaviti DEBUG promenljivu na True
# 9. Otkomentarisati linije koje počinju znakom !
# 10. Pokrenuti grader.sh pokretanjem ove ćelije
 
if DEBUG:
   path_grader = f'{path_root}grader.sh'
   !chmod +x '{path_grader}' # Dozvola za izvršavanje
   !bash '{path_grader}' '{path_root}' # Pokretanje gradera

# GRADER - END